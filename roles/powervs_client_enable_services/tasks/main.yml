---
####################################
# Block: configure proxy settings
####################################
- block:
    - set_fact:
        bash_file: /etc/bashrc
      when: ansible_distribution is match("RedHat*")
    - set_fact:
        bash_file: /etc/bash.bashrc
      when: ansible_distribution is match("SLES*")

    # If items are present, then update the item with passed squid server ip and port. Status of items is registered in the variable.
    - name: Check for http proxy entries in {{ bash_file }}
      replace:
        path: "{{ bash_file }}"
        regexp: "^(.*){{ item }}(.*)$"
        replace: "export {{ item }}=http://{{ client_config.squid.squid_server_ip_port }}"
      with_items:
        - http_proxy
        - https_proxy
        - HTTP_PROXY
        - HTTPS_PROXY
      register: replace_log
      when: client_config.squid.squid_server_ip_port is defined

    # If items are absent(status obtained from previous register value), then items will add be added.
    - name: Check for http proxy entries in {{ bash_file }}
      lineinfile:
        path: "{{ bash_file }}"
        regexp: "^(.*){{ item }}(.*)$"
        line: "export {{ item }}=http://{{ client_config.squid.squid_server_ip_port }}"
      with_items:
        - http_proxy
        - https_proxy
        - HTTP_PROXY
        - HTTPS_PROXY
      when:
        - client_config.squid.squid_server_ip_port is defined
        - not replace_log.changed

    # On RHEL additional check. Check if proxy entry is already present in /etc/dnf/dnf.conf. If yes, don't add new entries. Modify the value.
    - name: Check for proxy entry in /etc/dnf/dnf.conf on RHEL OS
      replace:
        path: "/etc/dnf/dnf.conf"
        regexp: "proxy(.*)$"
        replace: "proxy=http://{{ client_config.squid.squid_server_ip_port }}"
      register: replace_dnf_log
      when: client_config.squid.squid_server_ip_port is defined and ansible_distribution is match("RedHat*")

    # On RHEL additional check. If proxy_entry is absent(status obtained from previous register value), then proxy will add be added to the /etc/dnf/dnf.conf file.
    - name: Check for proxy entry in /etc/dnf/dnf.conf
      lineinfile:
        path: "/etc/dnf/dnf.conf"
        regexp: "proxy(.*)$"
        line: "proxy=http://{{ client_config.squid.squid_server_ip_port }}"
      when:
        - client_config.squid.no_proxy_hosts is defined
        - not replace_dnf_log.changed

    # Check if no_proxy entries are already present. If yes, don't add new entries but modify with the values passed in.
    - name: Check for http proxy entries in {{ bash_file }}
      replace:
        path: "{{ bash_file }}"
        regexp: "^(.*)no_proxy(.*)$"
        replace: "export no_proxy={{ client_config.squid.no_proxy_hosts }}"
      register: replace_noproxy_log
      when: client_config.squid.no_proxy_hosts is defined

    # If no_proxy is absent(status obtained from previous register value), then items will add be added.
    - name: Check for http proxy entries in {{ bash_file }}
      lineinfile:
        path: "{{ bash_file }}"
        regexp: "^(.*)no_proxy(.*)$"
        line: "export no_proxy={{ client_config.squid.no_proxy_hosts }}"
      when:
        - client_config.squid.no_proxy_hosts is defined
        - not replace_noproxy_log.changed

    # Test internet connectivity
    - name: Verify connection to internet
      ansible.builtin.uri:
        url: http://www.google.com

  when: client_config.squid.enable | default(false) | bool

####################################
# Block: install DNS
####################################
- block:
    ## Installing bind-utils
    - name: Installing bind-utils
      package:
        name: bind-utils
        state: present

    - name: Modifying /etc/resolv.conf file to add nameserver
      lineinfile:
        path: /etc/resolv.conf
        line: nameserver {{ client_config.dns.dns_server_ip }}

    - name: Pause for 60 sec
      pause:
        seconds: 60

    - name: Check for name resolution using dig command
      command: dig -i www.google.com +short
      register: dig_output
      changed_when: false
      ignore_errors: true

    - name: Verify if dig command returned an IP
      fail:
        msg: "DNS is not working, please verify setting"
      when: dig_output.stdout is not ansible.utils.ipv4
      ignore_errors: true

  when: client_config.dns.enable | default(false) | bool

####################################
# Block: install NTP
####################################
- block:
    ## Installing chrony
    - name: Installing chrony
      package:
        name: chrony
        state: present

    ## Modifying /etc/chrony.conf file
    - name: Replace iburst line in /etc/chrony.conf file
      replace:
        path: /etc/chrony.conf
        regexp: "^(.*)iburst$"
        replace: "server {{ client_config.ntp.ntp_server_ip }} iburst"

    ## Starting chronyd service
    - name: Start chronyd service
      service:
        name: chronyd
        state: restarted
        enabled: yes
      changed_when: false

    - name: Pause for 60 sec
      pause:
        seconds: 60

    - name: Verify Chrony configuration grepping for Leap status Normal using chronyc tracking
      command: chronyc tracking | grep Leap | grep Normal
      changed_when: false
  when: client_config.ntp.enable | default(false) | bool

####################################
# Block: install NFS and mount
####################################
- block:
    - name: Install NFS client package
      package:
        name: nfs-utils
        state: latest

    - name: Start and enable NFS client service
      service:
        name: nfs-client.target
        state: restarted
        enabled: yes
      changed_when: false

    - name: Create the NFS directory if it does not exist
      file:
        path: "{{ item }}"
        state: directory
        mode: "0755"
      with_items: "{{ client_config.nfs.nfs_client_path.split(';') }}"

    # Mounting NFS directory. server_path, should be "server_name":"source_path"
    - name: Mount NFS directory
      mount:
        path: "{{ item.0 }}"
        src: "{{ item.1 }}"
        state: mounted
        boot: yes
        opts: defaults,nofail
        fstype: nfs
      with_together:
        - "{{ client_config.nfs.nfs_client_path.split(';')  }}"
        - "{{ client_config.nfs.nfs_server_path.split(';')  }}"

    - name: Verify if mount point is accessible
      command: "ls -l {{ item }}"
      loop: "{{ client_config.nfs.nfs_client_path.split(';')  }}"
      changed_when: false
  when: client_config.nfs.enable | default(false) | bool
